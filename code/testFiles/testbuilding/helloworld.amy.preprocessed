// Sample Multi-File AmyScript program 
// By: Amy Burnett
//========================================================================

// AmyScript standard library 
// Author: Amy Burnett
//========================================================================


// Max function 
// Author: Amy Burnett
//========================================================================


template <:T:>
function T max (T a, T b)
{
    if (a >= b) return a;
    return b;
}


//========================================================================

    template <:T:>
    function T sum (T[] vals)
    {
        T sum = T();
        for (int i = 0; i < sizeof(vals); ++i)
            sum = sum + vals[i]; 
        return sum; 
    }

    template <:T:>
    function T min (T a, T b)
    {
        if (a <= b) return a;
        return b; 
    }

    function void print (int[] array)
    {
        print ('[');
        if (sizeof (array) > 0)
            print (array[0]);
        for (int i = 1; i < sizeof (array); ++i)
        {
            print (',');
            print (' ');
            print (array[i]);
        }
        print (']');
    }

    function void println (int[] array)
    {
        print (array);
        println ();
    }

    function void print (float[] array)
    {
        print ('[');
        if (sizeof (array) > 0)
            print (array[0]);
        for (int i = 1; i < sizeof (array); ++i)
        {
            print (',');
            print (' ');
            print (array[i]);
        }
        print (']');
    }

    function void println (float[] array)
    {
        print (array);
        println ();
    }

    template <:T:>
    function void merge (T[] array, int left, int mid, int right)
    {
        int leftArraySize = mid - left + 1;
        int rightArraySize = right - mid; 

        // Create temp arrays 
        T[] leftArray = new T[leftArraySize];
        T[] rightArray = new T[rightArraySize];

        // Copy data to temp arrays 
        for (int i = 0; i < leftArraySize; ++i)
            leftArray[i] = array[left + i];
        for (int j = 0; j < rightArraySize; ++j)
            rightArray[j] = array[mid + 1 + j];

        int i = 0;
        int j = 0;
        int k = left; 

        while (i < leftArraySize && j < rightArraySize)
        {
            if (leftArray[i] <= rightArray[j])
            {
                array[k++] = leftArray[i++];
            }
            else
            {
                array[k++] = rightArray[j++];
            }
        }

        // Copy over remaining of leftArray
        while (i < leftArraySize)
        {   
            array[k++] = leftArray[i++];
        }
        // Copy over remaining of rightArray
        while (j < rightArraySize)
        {   
            array[k++] = rightArray[j++];
        }

        // clean up temp arrays
        free (leftArray);
        free (rightArray);
    }

    template <:T:>
    function void mergeSort (T[] array, int begin, int end)
    {
        if (begin >= end) return;

        int mid = begin + (end - begin) / 2;
        mergeSort<:T:> (array, begin, mid);
        mergeSort<:T:> (array, mid + 1, end);
        merge<:T:> (array, begin, mid, end);
    }



//========================================================================
// AmyScript Vector implementation + testing 
// Author: Amy Burnett
//========================================================================

// includes are relative paths to the file that they are in
// AmyScript standard library 
// Author: Amy Burnett
//========================================================================


//========================================================================

//========================================================================

int INITIAL_CAPACITY = 10; 

//========================================================================

template <:data_type:>
class Vector
{

    public field data_type[] data; 
    public field int size; 
    public field int capacity; 

    //--------------------------------------------------------------------

    constructor ()
    {
        this.capacity = INITIAL_CAPACITY;
        this.size = 0; 
        this.data = new data_type[this.capacity];
    }

    //--------------------------------------------------------------------

    // gets the value at a given index 
    public method data_type get (int index)
    {
        return this.data[index]; 
    }

    //--------------------------------------------------------------------

    // sets the value at a given index
    public method void set (int index, data_type value)
    {
        this.data[index] = value; 
    }

    //--------------------------------------------------------------------

    // gets the size of the Vector
    public method int size ()
    {
        return this.size; 
    }

    //--------------------------------------------------------------------

    // returns true if this Vector is empty, false otherwise 
    public method int is_empty ()
    {
        return this.size == 0; 
    }

    //--------------------------------------------------------------------

    // pushes a given value to the end of the Vector
    // this is a constant operation if an increase in capacity is unneeded
    public method void push_back (data_type value)
    {
        // ensure capacity
        if (this.size == this.capacity)
        {
            // increase capacity
            this.capacity = this.capacity * 2; 
            // reallocate data with the larger capacity
            data_type[] new_data = new data_type[this.capacity];
            // copy values over
            for (int i = 0; i < this.size; ++i)
                new_data[i] = this.data[i];
            // free original array
            free (this.data);
            // save new array
            this.data = new_data; 
        }
        // insert new value
        this.data[this.size] = value;
        // increase size
        ++this.size; 
    }

    //--------------------------------------------------------------------

    // removes the last value in the Vector
    // this is always constant time 
    public method void pop_back ()
    {
        // ensure there are values to pop 
        if (this.size == 0)
            return; 
        // decrease size
        --this.size; 
    }

    //--------------------------------------------------------------------


}


//========================================================================

//========================================================================

function int main ()
{

    char[] temp = "=== Vector<:int:> ===================";
    println (temp);
    free (temp);

    Vector<:int:> nums = new Vector<:int:>();
    nums.push_back (5);
    nums.push_back (7);
    nums.push_back (21);
    nums.push_back (42);
    nums.push_back (3);
    nums.push_back (128);
    nums.push_back (32);
    nums.push_back (42);
    nums.push_back (10);
    nums.push_back (4);

    print ("N:   ");
    println (nums.size());

    print ("sum: ");
    println (sum<:int:>(nums.data));

    int max = 0;
    for (int i = 0; i < nums.size(); ++i)
    {
        max = max<:int:>(max, nums.data[i]);
    }

    int min = max;
    for (int i = 0; i < nums.size(); ++i)
    {
        min = min<:int:>(min, nums.data[i]);
    }

    print ("max: ");
    println (max);

    print ("min: ");
    println (min);

    temp = "Before sort: ";
    print (temp);
    free (temp);
    println (nums.data);

    // this only works correctly because nums.size should equal nums.capacity
    // also this merge sort implementation has an inclusive end (YUCK!)
    mergeSort<:int:> (nums.data, 0, nums.size()-1);

    temp = "After sort:  ";
    print (temp);
    free (temp);
    println (nums.data);

    temp = "=== Vector<:float:> =================";
    println (temp);
    free (temp);

    Vector<:float:> nums2 = new Vector<:float:> ();
    nums2.push_back (3.14);
    nums2.push_back (3.14);
    nums2.push_back (0.75);
    nums2.push_back (0.5);
    nums2.push_back (21.0);
    nums2.push_back (128.3);
    nums2.push_back (0.25);
    nums2.push_back (42.1);
    nums2.push_back (0.0);
    nums2.push_back (6.28);

    temp = "Before sort: ";
    print (temp);
    free (temp);
    println (nums2.data);

    // this only works correctly because nums.size should equal nums.capacity
    // also this merge sort implementation has an inclusive end (YUCK!)
    mergeSort<:float:> (nums2.data, 0, nums2.size()-1);

    temp = "After sort:  ";
    print (temp);
    free (temp);
    println (nums2.data);

    temp = "=== Vector<:char:> ==================";
    println (temp);
    free (temp);

    Vector<:char:> nums3 = new Vector<:char:> ();
    nums3.push_back ('f');
    nums3.push_back ('g');
    nums3.push_back ('k');
    nums3.push_back ('j');
    nums3.push_back ('d');
    nums3.push_back ('a');
    nums3.push_back ('q');
    nums3.push_back ('z');
    nums3.push_back ('m');
    nums3.push_back ('n');

    temp = "Before sort: ";
    print (temp);
    free (temp);
    println (nums3.data);

    // this only works correctly because nums.size should equal nums.capacity
    // also this merge sort implementation has an inclusive end (YUCK!)
    mergeSort<:char:> (nums3.data, 0, nums3.size()-1);

    temp = "After sort:  ";
    print (temp);
    free (temp);
    println (nums3.data);

}

main ();

//========================================================================
